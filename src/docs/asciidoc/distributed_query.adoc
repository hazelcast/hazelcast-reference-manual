

== Distributed Query

Distributed queries access data from multiple data sources stored on
either the same or different members.

Hazelcast partitions your data and spreads it across cluster of members.
You can iterate over the map entries and look for certain entries
(specified by predicates) you are interested in. However, this is not
very efficient because you have to bring the entire entry set and iterate
locally. Instead, Hazelcast allows you to run distributed queries on your
distributed map.


=== How Distributed Query Works

. The requested predicate is sent to each member in the cluster.
. Each member looks at its own local entries and filters them according
to the predicate. At this stage, key/value pairs of the entries are
deserialized and then passed to the predicate.
. The predicate requester merges all the results coming from each
member into a single set.

Distributed query is highly scalable. If you add new members to the
cluster, the partition count for each member is reduced and thus the
time spent by each member on iterating its entries is reduced. In addition,
the pool of partition threads evaluates the entries concurrently in each
member and the network traffic is also reduced since only filtered data
is sent to the requester.

Hazelcast offers the following APIs for distributed query purposes:

* Criteria API
* Distributed SQL Query


==== Employee Map Query Example

Assume that you have an "employee" map containing values of
`Employee` objects, as coded below.

[source,java]
----
public class Employee implements Serializable {
    private String name;
    private int age;
    private boolean active;
    private double salary;

    public Employee(String name, int age, boolean active, double salary) {
        this.name = name;
        this.age = age;
        this.active = active;
        this.salary = salary;
    }

    public Employee() {
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    public double getSalary() {
        return salary;
    }

    public boolean isActive() {
        return active;
    }
}
----

Now let's look for the employees who are active and have an age less
than 30 using the aforementioned APIs (Criteria API and Distributed
SQL Query). The following subsections describe each query mechanism
for this example.

NOTE: When using Portable objects, if one field of an object exists
on one member but does not exist on another one, Hazelcast does not
throw an unknown field exception.
Instead, Hazelcast treats that predicate, which tries to perform a
query on an unknown field, as an always false predicate.


==== Querying with Criteria API

Criteria API is a programming interface offered by Hazelcast that
is similar to the Java Persistence Query Language (JPQL). Below
is the code for the <<employee-map-query-example, above example query>>.

[source,java]
----
IMap<String, Employee> map = hazelcastInstance.getMap( "employee" );

EntryObject e = new PredicateBuilder().getEntryObject();
Predicate predicate = e.is( "active" ).and( e.get( "age" ).lessThan( 30 ) );

Collection<Employee> employees = map.values( predicate );
----

In the above example code, `predicate` verifies whether the entry is
active and its `age` value is less than 30. This `predicate` is
applied to the `employee` map using the `map.values(predicate)` method.
This method sends the predicate to all cluster members
and merges the results coming from them. Since the predicate is
communicated between the members, it needs to
be serializable.

NOTE: Predicates can also be applied to `keySet`, `entrySet` and
`localKeySet` of the Hazelcast distributed map.

===== Predicates Class Operators

The `Predicates` class includes many operators for your query requirements.
The following are descriptions for some of them:

* `equal`: Checks if the result of an expression is equal to a given value.
* `notEqual`: Checks if the result of an expression is not equal to a given value.
* `instanceOf`: Checks if the result of an expression has a certain type.
* `like`: Checks if the result of an expression matches some string pattern. %
(percentage sign) is the placeholder for many characters,  (underscore) is
placeholder for only one character.
* `greaterThan`: Checks if the result of an expression is greater than a
certain value.
* `greaterEqual`: Checks if the result of an expression is greater than or
equal to a certain value.
* `lessThan`: Checks if the result of an expression is less than a certain
value.
* `lessEqual`: Checks if the result of an expression is less than or equal
to a certain value.
* `between`: Checks if the result of an expression is between two values
(this is inclusive).
* `in`: Checks if the result of an expression is an element of a certain
collection.
* `isNot`: Checks if the result of an expression is false.
* `regex`: Checks if the result of an expression matches some regular
expression.


NOTE: See the
link:https://docs.hazelcast.org/docs/latest/javadoc/com/hazelcast/query/Predicates.html[Predicates Javadoc^]
for all predicates provided.


===== Combining Predicates with AND, OR, NOT

You can combine predicates using the `and`, `or` and `not` operators,
as shown in the below examples.

[source,java]
----
public Collection<Employee> getWithNameAndAge( String name, int age ) {
    Predicate namePredicate = Predicates.equal( "name", name );
    Predicate agePredicate = Predicates.equal( "age", age );
    Predicate predicate = Predicates.and( namePredicate, agePredicate );
    return employeeMap.values( predicate );
}
----

[source,java]
----
public Collection<Employee> getWithNameOrAge( String name, int age ) {
    Predicate namePredicate = Predicates.equal( "name", name );
    Predicate agePredicate = Predicates.equal( "age", age );
    Predicate predicate = Predicates.or( namePredicate, agePredicate );
    return employeeMap.values( predicate );
}
----

[source,java]
----
public Collection<Employee> getNotWithName( String name ) {
    Predicate namePredicate = Predicates.equal( "name", name );
    Predicate predicate = Predicates.not( namePredicate );
    return employeeMap.values( predicate );
}
----

===== Simplifying with PredicateBuilder

You can simplify predicate usage with the `PredicateBuilder` class,
which offers simpler predicate building. See the
below example code which selects all people with a certain name and age.

[source,java]
----
public Collection<Employee> getWithNameAndAgeSimplified( String name, int age ) {
    EntryObject e = new PredicateBuilder().getEntryObject();
    Predicate agePredicate = e.get( "age" ).equal( age );
    Predicate predicate = e.get( "name" ).equal( name ).and( agePredicate );
    return employeeMap.values( predicate );
}
----

==== Querying with SQL

`com.hazelcast.query.SqlPredicate` takes the regular SQL `where` clause.
Here is an example:

[source,java]
----
IMap<String, Employee> map = hazelcastInstance.getMap( "employee" );
Set<Employee> employees = map.values( new SqlPredicate( "active AND age < 30" ) );
----

===== Supported SQL Syntax

**AND/OR:** `<expression> AND <expression> AND <expression>... `

* `active AND age>30`
* `active=false OR age = 45 OR name = 'Joe'`
* `active AND ( age > 20 OR salary < 60000 )`

**Equality:** `=, !=, <, <=, >, >=`

* `<expression> = value`
* `age <= 30`
* `name = 'Joe'`
* `salary != 50000`

**BETWEEN: ** `<attribute> [NOT] BETWEEN <value1> AND <value2>`

* `age BETWEEN 20 AND 33 ( same as age >= 20  AND age <= 33 )`
* `age NOT BETWEEN 30 AND 40 ( same as age < 30 OR age > 40 )`


**IN:** `<attribute> [NOT] IN (val1, val2,...)`

* `age IN ( 20, 30, 40 )`
* `age NOT IN ( 60, 70 )`
* `active AND ( salary >= 50000 OR ( age NOT BETWEEN 20 AND 30 ) )`
* `age IN ( 20, 30, 40 ) AND salary BETWEEN ( 50000, 80000 )`

**LIKE:** `<attribute> [NOT] LIKE "expression"`

The `%` (percentage sign) is placeholder for multiple characters,
an `_` (underscore) is placeholder for only one character.

* `name LIKE 'Jo%'` (true for 'Joe', 'Josh', 'Joseph' etc.)
* `name LIKE 'Jo_'` (true for 'Joe'; false for 'Josh')
* `name NOT LIKE 'Jo_'` (true for 'Josh'; false for 'Joe')
* `name LIKE 'J_s%'` (true for 'Josh', 'Joseph'; false 'John', 'Joe')


**ILIKE:** `<attribute> [NOT] ILIKE 'expression'`

Similar to LIKE predicate but in a case-insensitive manner.

* `name ILIKE 'Jo%'` (true for 'Joe', 'joe', 'jOe','Josh','joSH', etc.)
* `name ILIKE 'Jo_'` (true for 'Joe' or 'jOE'; false for 'Josh')

**REGEX**: `<attribute> [NOT] REGEX 'expression'`

* `name REGEX 'abc-.*'` (true for 'abc-123'; false for 'abx-123')

===== Querying Entry Keys with Predicates

You can use `__key` attribute to perform a predicated search for entry
keys. See the following example:

[source,java]
----
IMap<String, Person> personMap = hazelcastInstance.getMap(persons);
personMap.put("Alice", new Person("Alice", 35, Gender.FEMALE));
personMap.put("Andy",  new Person("Andy",  37, Gender.MALE));
personMap.put("Bob",   new Person("Bob",   22, Gender.MALE));
[...]
Predicate predicate = new SqlPredicate("__key like A%");
Collection<Person> startingWithA = personMap.values(predicate);
----

In this example, the code creates a collection with the entries whose
keys start with the letter "A”.

==== Querying JSON Strings

You can query JSON strings stored inside your Hazelcast clusters. To
query a JSON string,
you first need to create a `HazelcastJsonValue` from the JSON string.
You can use ``HazelcastJsonValue``s both as keys and values in the
distributed data structures. Then, it is
possible to query these objects using the Hazelcast query methods
explained in this section.

[source,java]
----
String person1 = "{ \"name\": \"John\", \"age\": 35 }";
String person2 = "{ \"name\": \"Jane\", \"age\": 24 }";
String person3 = "{ \"name\": \"Trey\", \"age\": 17 }";

IMap<Integer, HazelcastJsonValue> idPersonMap = instance.getMap("jsonValues");

idPersonMap.put(1, new HazelcastJsonValue(person1));
idPersonMap.put(2, new HazelcastJsonValue(person2));
idPersonMap.put(3, new HazelcastJsonValue(person3));

Collection<HazelcastJsonValue> peopleUnder21 = idPersonMap.values(Predicates.lessThan("age", 21));
----

When running the queries, Hazelcast treats values extracted from
the JSON documents as Java types so they
can be compared with the query attribute. JSON specification
defines five primitive types to be used in the JSON
documents: `number`,`string`, `true`, `false` and `null`. The `string`,
`true/false` and `null` types are treated
as `String`, `boolean` and `null`, respectively. We treat the extracted
`number` values as ``long``s if they
can be represented by a `long`. Otherwise, ``number``s are treated
as ``double``s.

It is possible to query nested attributes and arrays in JSON documents.
The query syntax is the same
as querying other Hazelcast objects as explained in the
<<querying-in-collections-and-arrays, Querying in Collections and Arrays section>>.

[source,java]
----
/**
 * Sample JSON object
 *
 * {
 *     "departmentId": 1,
 *     "room": "alpha",
 *     "people": [
 *         {
 *             "name": "Peter",
 *             "age": 26,
 *             "salary": 50000
 *         },
 *         {
 *             "name": "Jonah",
 *             "age": 50,
 *             "salary": 140000
 *         }
 *     ]
 * }
 *
 *
 * The following query finds all the departments that have a person named "Peter" working in them.
 */
Collection<HazelcastJsonValue> departmentWithPeter = departments.values(Predicates.equal("people[any].name", "Peter"));
----

`HazelcastJsonValue` is a lightweight wrapper around your JSON strings.
It is used merely as a way to indicate
that the contained string should be treated as a valid JSON value.
Hazelcast does not check the validity of JSON
strings put into to maps. Putting an invalid JSON string in a map is
permissible. However, in that case
whether such an entry is going to be returned or not from a query is not defined.

===== Metadata Creation for JSON Querying

Hazelcast stores a metadata object per `HazelcastJsonValue` stored.
This metadata object is created every time
a `HazelcastJsonValue` is put into an IMap. Metadata is later used
to speed up the query operations. Metadata creation
is on by default. Depending on your application's needs, you may want
to turn off the metadata creation
to decrease the put latency and increase the throughput. You can configure
this using <<metadata-policy, Metadata Policy>>.

NOTE: JSON metadata is stored on-heap even when you use the `NATIVE`
in-memory format. If you are storing
``HazelcastJsonValue``s in your `NATIVE` maps, there is a certain
amount of on-heap cost per object. Metadata is not created unless you
put ``HazelcastJsonValue``s in your `NATIVE` maps even when metadata
creation is on.

==== Filtering with Paging Predicates

Hazelcast provides paging for defined predicates. With its `PagingPredicate`
class, you can
get a collection of keys, values, or entries page by page by filtering
them with predicates and giving the size of the pages. Also, you
can sort the entries by specifying comparators. In this case, the comparator
should be `Serializable` and the serialization factory implementations you use,
e.g., `PortableFactory` and `DataSerializableFactory`, should be registered.
See the <<serialization, Serialization chapter>> on how to register these
factories.

Paging predicates require the objects to be deserialized both on the calling
side (either a member or client) and the member side from which the collection
is retrieved. Therefore, you need to register the serialization factories
you use on all the members and clients on which the paging predicates are used.
See the <<serialization, Serialization chapter>> on how to register these
factories.

In the example code below:

* The `greaterEqual` predicate gets values from the "students" map. This
predicate has a filter
to retrieve the objects with an "age" greater than or equal to 18.
* Then a `PagingPredicate` is constructed in which the page size is 5,
so that there are five objects in each page.
The first time the values are called creates the first page.
* It gets subsequent pages with the `nextPage()`
method of `PagingPredicate` and querying the map again with the
updated `PagingPredicate`.

[source,java]
----
IMap<Integer, Student> map = hazelcastInstance.getMap( "students" );
Predicate greaterEqual = Predicates.greaterEqual( "age", 18 );
PagingPredicate pagingPredicate = new PagingPredicate( greaterEqual, 5 );
// Retrieve the first page
Collection<Student> values = map.values( pagingPredicate );
...
// Set up next page
pagingPredicate.nextPage();
// Retrieve next page
values = map.values( pagingPredicate );
...
----

If a comparator is not specified for `PagingPredicate`, but you want
to get a collection of keys or values page by page, this collection must
be an instance of `Comparable` (i.e., it must implement `java.lang.Comparable`).
Otherwise, the `java.lang.IllegalArgument` exception is thrown.

You can also access a specific page more
easily with the help of the `setPage()` method. This way, if you make
a query for the hundredth page, for example, it gets all 100 pages at
once instead of reaching the hundredth page one by one using the `nextPage()` method.
Note that this feature tires the memory and see the
link:https://docs.hazelcast.org/docs/latest/javadoc/com/hazelcast/query/PagingPredicate.html[PagingPredicate Javadoc^].

Paging Predicate, also known as Order & Limit, is not supported in
Transactional Context.

==== Filtering with Partition Predicate

You can run queries on a single partition in your cluster using
the partition predicate (`PartitionPredicate`).

It takes a predicate and partition key as parameters, gets the
partition ID using the key and  runs that predicate only on the partition
where that key belongs.

See the following code snippet:

[source,java]
----
...
Predicate predicate = new PartitionPredicate<String, Integer>(partitionKey, TruePredicate.INSTANCE);

Collection<Integer> values = map.values(predicate);
Collection<String> keys = map.keySet(predicate);
...
----

By default there are 271 partitions, and using a regular predicate,
each partition needs to be accessed. However, if the
partition predicate only accesses a single partition, this can lead
to a big performance gain.

For the partition predicate to work correctly, you need to know which
partition your data belongs to so that you can send the
request to the correct partition. One of the ways of doing it is to
make use of the `PartitionAware` interface when data is
inserted, thereby controlling the owning partition. See the
<<partitionaware, PartitionAware section>> for more information and examples.

A concrete example may be a web shop that sells phones and accessories.
To find all the accessories of a phone,
a query could be executed that selects all accessories for that phone.
This query is executed on all members in the cluster and
therefore could generate quite a lot of load. However, if we would store
the accessories in the same partition as the phone, the
partition predicate could use the `partitionKey` of the phone to select
the right partition and then it queries for
the accessories for that phone; and this reduces the load on the system
and get faster query results.

==== Indexing Queries

Hazelcast distributed queries run on each member in parallel and return
only the results to the caller.
Then, on the caller side, the results are merged.

When a query runs on a
member, Hazelcast iterates through all the owned entries and find the
matching ones. This can be made faster by indexing
the mostly queried fields, just like you would do for your database.
Indexing adds overhead for each `write`
operation but queries will be a lot faster. If you query your map a
lot, make sure to add indexes for the most frequently
queried fields. For example, if you do an `active and age < 30` query,
make sure you add an index for the `active` and
`age` fields. The following example code does that by getting the map
from the Hazelcast instance and adding indexes to the map with the
IMap `addIndex` method.

[source,java]
----
IMap map = hazelcastInstance.getMap( "employees" );
// ordered, since we have ranged queries for this field
map.addIndex( "age", true );
// not ordered, because boolean field cannot have range
map.addIndex( "active", false );
----

Note that creating indexes once is sufficient. Subsequent operations are
reflected in the index automatically. So, although it is safe to call the
`addIndex()` method consecutively, there will be a performance penalty
due to the redundant index creation.

When you call, for example, `map.addIndex("fieldName", true)`, each
partition iterates over their recordset and creates an index for each entry.
The previously created index entry will be recreated and replaced with the new entry.
The performance penalty will be parallel with the number of entries. If you
have maps with a large number of entries, then synchronizing index addition process
is recommended.

Other than using the `addIndex()` method, you can define your index
declaratively or programmatically as described in the <<configuring-imap-indexes section>>.

===== Indexing Ranged Queries

`IMap.addIndex(fieldName, ordered)` is used for adding index. For
each indexed field, if you have ranged queries such as `age>30`,
`age BETWEEN 40 AND 60`, then you should set the `ordered` parameter
to `true`. Otherwise, set it to `false`.

===== Configuring IMap Indexes

Also, you can define `IMap` indexes in configuration. An example is
shown below.

[source,xml]
----
<hazelcast>
    ...
    <map name="default">
        <indexes>
            <index ordered="false">name</index>
            <index ordered="true">age</index>
        </indexes>
    </map>
    ...
</hazelcast>
----

You can also define `IMap` indexes using programmatic configuration,
as in the example below.

[source,java]
----
mapConfig.addMapIndexConfig( new MapIndexConfig( "name", false ) );
mapConfig.addMapIndexConfig( new MapIndexConfig( "age", true ) );
----

The following is the Spring declarative configuration for the same
example.

[source,xml]
----
<hz:map name="default">
    <hz:indexes>
        <hz:index attribute="name"/>
        <hz:index attribute="age" ordered="true"/>
    </hz:indexes>
</hz:map>
----

NOTE: Non-primitive types to be indexed should implement *`Comparable`*.

NOTE: If you configure the data structure to use
<<configuring-high-density-memory-store, High-Density Memory Store>> **and**
indexes, the indexes are automatically stored in the High-Density Memory Store
as well. This prevents from running into full garbage collections when doing
a lot of updates to index.

===== Composite Indexes

Composite indexes, also known as compound indexes, are special kind of
indexes that are built on top of the multiple map entry attributes and
therefore may be used to significantly speed up the queries involving
those attributes simultaneously.

There are two distinct composite index types used for two different
purposes: unordered composite indexes and ordered ones.

====== Unordered Composite Indexes

The unordered indexes are used to perform equality queries, also known
as the point queries, e.g., `name = 'Alice'`. These are specifically
optimized for equality queries and don't support other comparison operators
like `>` or `+<=+`.

Additionally, the _composite_ unordered indexes allow speeding up the equality
queries involving multiple attributes simultaneously, e.g., `name = 'Alice'
and age = 33`. This example query results in a single composite index lookup
operation which can be performed very efficiently.

The unordered composite index on the `name` and `age` attributes may be
configured for a map as follows:

[source,xml]
----
<hazelcast>
    ...
    <map name="persons">
        <indexes>
            <index ordered="false">name, age</index>
        </indexes>
    </map>
    ...
</hazelcast>
----

The attributes indexed by the _unordered_ composite indexes can't be
matched partially: the `name = 'Alice'` query can't utilize the composite
index configured above.

====== Ordered Composite Indexes

The ordered indexes are specifically designed to perform efficient order
comparison queries, also known as the range queries, e.g., `age > 33`. The
equality queries, like `age = 33`, are still supported by the ordered indexes,
but they are handled in a slightly less efficient manner comparing to the
unordered indexes.

The _composite_ ordered indexes extend the concept by allowing multiple
equality predicates and a single order comparison predicate to be combined
into a single index query operation. For instance, the `name = 'Alice' and
age > 33` and `name = 'Bob' and age = 33 and balance > 0.0` queries are good
candidates to be covered by an ordered composite index configured as follows:

[source,xml]
----
<hazelcast>
    ...
    <map name="persons">
        <indexes>
            <index ordered="true">name, age, balance</index>
        </indexes>
    </map>
    ...
</hazelcast>
----

Unlike the _unordered_ composite indexes, partial attribute prefixes may be
matched for the _ordered_ composite indexes. In general, a valid non-empty
attribute prefix is formed as a sequence of zero or more equality predicates
followed by a zero or exactly one order comparison predicate. Given the index
definition above, the following queries may be served by the index: `name = 'Alice'`,
`name > 'Alice'`, `name = 'Alice' and age > 33`, `name = 'Alice' and age = 33 and
balance = 5.0`. The following queries can't be served the index: `age = 33`,
`age > 33 and balance = 0.0`, `balance > 0.0`.

While matching the ordered composite indexes, multiple order comparison
predicates acting on the same attribute are treated as a single range
predicate acting on that attribute. Given the index definition above, the
following queries may be served by the index: `name > 'Alice' and name < 'Bob'`,
`name = 'Alice' and age > 33 and age < 55`, `name = 'Alice' and age = 33 and
balance > 0.0 and balance < 100.0`.

====== Composite Index Matching and Selection

The order of attributes involved in a query plays no role in the selection
of the matching composite index: `name = 'Alice' and age = 33` and
`age = 33 and name = 'Alice'` queries are equivalent from the point of
view of the index matching procedure.

The attributes involved in a query can be matched partially by the composite
index matcher: `name = 'Alice' and age = 33 and balance > 0.0` can be
partially matched by the `name, age` composite index, the `name = 'Alice'
and age = 33` predicates are served by the matched index, while the
`balance > 0.0` predicate is processed by other means.

===== Copying Indexes

The underlying data structures used by the indexes need to copy the
query results to make sure that the results are correct. This copying
process is performed either when reading the index from the data
structure (on-read) or writing to it (on-write).

On-read copying means that, for each index-read operation, the result
of the query is copied before it is sent to the caller. Depending on
the query result's size, this type of index copying may be slower since
the result is stored in a map, i.e., all entries need to have the hash
calculated before being stored. Unlike the index-read operations, each
index-write operation is fast, since there is no copying. So, this
option can be preferred in index-write intensive cases.

On-write copying means that each index-write operation completely copies
the underlying map to provide the copy-on-write semantics and this may
be a slow operation depending on the index size. Unlike index-write operations,
each index-read operation is fast since the operation only includes accessing
the map that stores the results and returning them to the caller.

Another option is never copying the results of a query to a separate map.
This means the results backed by the underlying index-map can change after
the query has been executed (such as an entry might have been added or removed
from an index, or it might have been remapped). This option can be preferred
if you expect "mostly correct" results, i.e., if it is not a problem when
some entries returned in the query result set do not match the initial query
criteria. This is the fastest option since there is no copying.

You can set one these options using the system property
`hazelcast.index.copy.behavior`. The following values, which are explained
in the above paragraphs, can be set:

* `COPY_ON_READ` (the default value)
* `COPY_ON_WRITE`
* `NEVER`

NOTE: Usage of this system property is supported for BINARY and OBJECT
in-memory formats. Only in Hazelcast 3.8.7, it is also supported for
NATIVE in-memory format.

===== Indexing Attributes with ValueExtractor

You can also define custom attributes that may be referenced in predicates,
queries and indexes. Custom attributes can be defined by implementing a
`ValueExtractor`. See the <<custom-attributes, Custom Attributes section>>
for details.

===== Using "this" as an Attribute

You can use the keyword `this` as an attribute name while adding an
index or creating a predicate. A basic usage is shown below.

[source,java]
----
map.addIndex("this", true);
Predicate<Integer, Integer> lessEqual = Predicates.between("this", 12, 20);
----

Another basic example using `SqlPredicate` is shown below.

[source,java]
----
new SqlPredicate("this = 'jones'")
new SqlPredicate("this.age > 33")
----

The special attribute `this` acts on the value of a map entry. Typically,
you do not need to specify it while accessing a property of an entry's
value, since its presence is implicitly assumed if the special attribute
<<querying-entry-keys-with-predicates, __key>> is not specified.

==== Configuring Query Thread Pool

You can change the size of thread pool dedicated to query operations
using the `pool-size` property. Each query consumes a single thread
from a Generic Operations ThreadPool on each Hazelcast member - let's
call it the query-orchestrating thread.  That thread is blocked throughout
the whole execution-span of a query on the member.

The query-orchestrating thread uses the threads from the query-thread
pool in the following cases:

* if you run a `PagingPredicate` (since each page runs as a separate task)
* if you set the system property `hazelcast.query.predicate.parallel.evaluation`
to true (since the predicates are evaluated in parallel)

See the <<filtering-with-paging-predicates, Filtering with Paging Predicates section>>
and <<parallel-predicates, System Properties appendix>> for information on paging
predicates and for description of the above system property.

Below is an example of that declarative configuration.

[source,xml]
----
<hazelcast>
    ...
    <executor-service name="hz:query">
        <pool-size>100</pool-size>
    </executor-service>
    ...
</hazelcast>
----

Below is the equivalent programmatic configuration.

[source,java]
----
Config cfg = new Config();
cfg.getExecutorConfig("hz:query").setPoolSize(100);
----

===== Query Requests from Clients

When dealing with the query requests coming from the clients to your
members, Hazelcast offers the following system properties to tune your
thread pools:

* `hazelcast.clientengine.thread.count` which is the number of threads
to process non-partition-aware client requests, like `map.size()` and
executor tasks. Its default value is the number of cores multiplied by 20.
* `hazelcast.clientengine.query.thread.count` which is the number of
threads to process query requests coming from the clients. Its default
value is the number of cores.

If there are a lot of query request from the clients, you may want to
increase the value of `hazelcast.clientengine.query.thread.count`. In
addition to this tuning, you may also consider increasing the value of
`hazelcast.clientengine.thread.count` if the CPU load in your system is
not high and there is plenty of free memory.

=== Querying in Collections and Arrays

Hazelcast allows querying in collections and arrays.
Querying in collections and arrays is compatible with all Hazelcast
serialization methods, including the Portable serialization.


Let's have a look at the following data structure expressed in pseudo-code:

[source,java]
----
class Motorbike {
    Wheel wheels[2];
}

class Wheel {
   String name;

}
----

In order to query a single element of a collection/array, you can execute the following query:

[source,java]
----
// it matches all motorbikes where the zero wheel's name is 'front-wheel'
Predicate p = Predicates.equal("wheels[0].name", "front-wheel");
Collection<Motorbike> result = map.values(p);
----

It is also possible to query a collection/array using the `any` semantic as shown below:

[source,java]
----
// it matches all motorbikes where any wheel's name is 'front-wheel'
Predicate p = Predicates.equal("wheels[any].name", "front-wheel");
Collection<Motorbike> result = map.values(p);
----

The exact same query may be executed using the `SQLPredicate` as shown below:

[source,java]
----
Predicate p = new SqlPredicate("wheels[any].name = 'front-wheel'");
Collection<Motorbike> result = map.values(p);
----

`[]` notation applies to both collections and arrays.

[NOTE]
====
Hazelcast requires all elements of a collection to have the same type. Considering
and expanding the above example:

* If you have a `wheels` collection attribute, all of its elements must be of
the `Wheel` type, subclasses of `Wheel` are not allowed.
* Let’s say you have added a `seats` collection attribute, which is a `Seat`
object.  Then all of its elements must of this concrete `Seat` type.

So, you may have collections of different types in your map. However, each
collection’s elements must be of the same concrete type within that collection
attribute.

Consider custom attribute extractors if it is impossible or undesirable to reduce
the variety of types to a single type. See the <<custom-attributes, Custom Attributes section>>
for information on them.
====

==== Indexing in Collections and Arrays

You can also create an index using a query in collections and arrays.

Please note that in order to leverage the index, the attribute name used
in the query has to be the same as the one used
in the index definition.

Let's assume you have the following index definition:

[source,xml]
----
<hazelcast>
    ...
    <indexes>
        <index ordered="false">wheels[any].name</index>
    </indexes>
    ...
</hazelcast>
----

The following query uses the index:

[source,java]
----
Predicate p = Predicates.equal("wheels[any].name", "front-wheel");
----

The following query, however, does NOT leverage the index, since it does
not use exactly the same attribute name that
was used in the index:

[source,java]
----
Predicates.equal("wheels[0].name", "front-wheel")
----

In order to use the index in the case mentioned above, you have to create
another index, as shown below:

[source,xml]
----
<hazelcast>
    ...
    <indexes>
        <index ordered="false">wheels[0].name</index>
    </indexes>
    ...
</hazelcast>
----

==== Corner cases

Handling of corner cases may be a bit different than in a programming
language like `Java`.

Let's have a look at the following examples in order to understand the differences.
To make the analysis simpler, let's assume that there is only one `Motorbike`
object stored in a Hazelcast Map.

[cols="1,5,3,1,1"]
|===
|Id|Query|Data State|Extraction Result|Match

| 1
| `Predicates.equal("wheels[7].name", "front-wheel")`
| `wheels.size() == 1`
| `null`
| No

| 2
| `Predicates.equal("wheels[7].name", null)`
| `wheels.size() == 1`
| `null`
| Yes

| 3
| `Predicates.equal("wheels[0].name", "front-wheel")`
| `wheels[0].name == null`
| `null`
| No

| 4
| `Predicates.equal("wheels[0].name", null)`
| `wheels[0].name == null`
| `null`
| Yes

| 5
| `Predicates.equal("wheels[0].name", "front-wheel")`
| `wheels[0] == null`
| `null`
| No
| 6
| `Predicates.equal("wheels[0].name", null)`
| `wheels[0] == null`
| `null`
| Yes

| 7
| `Predicates.equal("wheels[0].name", "front-wheel")`
| `wheels == null`
| `null`
| No

| 8
| `Predicates.equal("wheels[0].name", null)`
| `wheels == null`
| `null`
| Yes
|===

As you can see, **no** ``NullPointerException``s or ``IndexOutOfBoundException``s
are thrown in the extraction process, even
though parts of the expression are `null`.

Looking at examples 4, 6 and 8, we can also easily notice that it is impossible to
distinguish which part of the
expression was null.
If we execute the following query `wheels[1].name = null`, it may be evaluated to
true because:

* `wheels` collection/array is null
* `index == 1` is out of bound
* `name` attribute of the wheels[1] object is `null`.

In order to make the query unambiguous, extra conditions would have to be added, e.g.,
`wheels != null AND wheels[1].name = null`.

=== Custom Attributes

It is possible to define a custom attribute that may be referenced in predicates,
queries and indexes.

A custom attribute is a "synthetic" attribute that does not exist as a `field` or
a `getter` in the object that it is extracted from.
Thus, it is necessary to define the policy on how the attribute is supposed to be
extracted.
Currently the only way to extract a custom attribute is to implement a
`com.hazelcast.query.extractor.ValueExtractor`
that encompasses the extraction logic.

Custom Attributes are compatible with all Hazelcast serialization methods,
including the Portable serialization.

==== Implementing a ValueExtractor

In order to implement a `ValueExtractor`, extend the abstract
`com.hazelcast.query.extractor.ValueExtractor` class
and implement the `extract()` method. This method does not return any values
since the extracted value is collected by the `ValueCollector`.
In order to return multiple results from a single extraction, invoke the
`ValueCollector.collect()` method
multiple times, so that the collector collects all results.

See the link:https://docs.hazelcast.org/docs/latest/javadoc/com/hazelcast/query/extractor/ValueExtractor.html[ValueExtractor^] and
link:https://docs.hazelcast.org/docs/latest/javadoc/com/hazelcast/query/extractor/ValueCollector.html[ValueCollector^] Javadocs.

===== ValueExtractor with Portable Serialization

Portable serialization is a special kind of serialization where there
is no need to have the class of the serialized object on the
classpath in order to read its attributes. That is the reason why the
target object passed to the `ValueExtractor.extract()`
method is not of the exact type that has been stored. Instead, an instance
of a `com.hazelcast.query.extractor.ValueReader` is passed.
`ValueReader` enables reading the attributes of a Portable object in a
generic and type-agnostic way.
It contains two methods:

* `read(String path, ValueCollector<T> collector)` - enables passing all
results directly to the `ValueCollector`.
* `read(String path, ValueCallback<T> callback)` - enables filtering, transforming
and grouping the result of the read operation and manually passing it to the
`ValueCollector`.

See the link:https://docs.hazelcast.org/docs/latest/javadoc/com/hazelcast/query/extractor/ValueReader.html[ValueReader^] Javadoc.

===== Returning Multiple Values from a Single Extraction

It sounds counter-intuitive, but a single extraction may return multiple
values when arrays or collections are
involved.
Let's have a look at the following data structure in pseudo-code:

[source,java]
----
class Motorbike {
    Wheel wheel[2];
}

class Wheel {
    String name;
}
----

Let's assume that we want to extract the names of all wheels from a
single motorbike object. Each motorbike has two
wheels so there are two names for each bike. In order to return both
values from the extraction operation, collect them
separately using the `ValueCollector`. Collecting multiple values in
this way allows you to operate on these multiple
values as if they were single values during the evaluation of the predicates.

Let's assume that we registered a custom extractor with the name `wheelName`
and executed the following query:
`wheelName = front-wheel`.

The extraction may return up to two wheel names for each `Motorbike` since
each `Motorbike` has up to two wheels.
In such a case, it is enough if a single value evaluates the predicate's
condition to true to return a match, so
it returns a `Motorbike` if "any" of the wheels matches the expression.

==== Extraction Arguments

A `ValueExtractor` may use a custom argument if it is specified in the query.
The custom argument may be passed within the square brackets located after the
name of the custom attribute,
e.g., `customAttribute[argument]`.

Let's have a look at the following query: `currency[incoming] == EUR`
The `currency` is a custom attribute that uses a `com.test.CurrencyExtractor`
for extraction.

The string `incoming` is an argument that is passed to the `ArgumentParser`
during the extraction.
The parser parses the string according to its custom logic and it returns a
parsed object.
The parsed object may be a single object, array, collection, or any arbitrary
object.
It is up to the `ValueExtractor`'s implementor to understand the semantics of
the parsed argument object.

For now it is **not** possible to register a custom `ArgumentParser`, thus a
default parser is used.
It follows a `pass-through` semantic, which means that the string located in
the square brackets is passed "as is" to
the `ValueExtractor.extract()` method.

Please note that using square brackets within the argument string is not allowed.

==== Configuring a Custom Attribute Programmatically

The following snippet demonstrates how to define a custom attribute using a `ValueExtractor`.

[source,java]
----
AttributeConfig attributeConfig = new AttributeConfig();
attributeConfig.setName("currency");
attributeConfig.setExtractorClassName("com.bank.CurrencyExtractor");

MapConfig mapConfig = new MapConfig();
mapConfig.addAttributeConfig(attributeConfig);
----

`currency` is the name of the custom attribute that will be extracted using
the `CurrencyExtractor` class.

Keep in mind that an extractor may not be added after the map has been instantiated.
All extractors have to be defined upfront in the map's initial configuration.

==== Configuring a Custom Attribute Declaratively

The following snippet demonstrates how to define a custom attribute in the
Hazelcast XML Configuration.

[source,xml]
----
<hazelcast>
    ...
    <map name="trades">
        <attributes>
            <attribute extractor-class-name="com.bank.CurrencyExtractor">currency</attribute>
        </attributes>
    </map>
    ...
</hazelcast>
----

Analogous to the example above, `currency` is the name of the custom attribute
that will be extracted using the
`CurrencyExtractor` class.

Please note that an attribute name may begin with an ASCII letter [A-Za-z] or
digit [0-9] and may contain
ASCII letters [A-Za-z], digits [0-9] or underscores later on.

==== Indexing Custom Attributes

You can create an index using a custom attribute.

The name of the attribute used in the index definition has to match the one
used in the attributes configuration.

Defining indexes with extraction arguments is allowed, as shown in the example
below:

[source,xml]
----
<hazelcast>
    ...
    <indexes>
        <!-- custom attribute without an extraction argument -->
        <index ordered="true">currency</index>
        <!-- custom attribute using an extraction argument -->
        <index ordered="true">currency[incoming]</index>
    </indexes>
    ...
</hazelcast>
----

[[fast-aggregations]]
=== Aggregations

Aggregations allow to compute a value of some function (e.g sum or max) over the
stored map entries. The computation is performed in a fully distributed manner,
so no data other than the computed function value is transferred to a caller,
making the computation fast.

NOTE: If the <<setting-in-memory-format, in-memory format>> of your data is `NATIVE`,
aggregations always run on the partition threads. If the data is of type `BINARY`
or `OBJECT`, they also mostly run on the partition threads, however, they may run on
the separate query threads to avoid blocking partition threads (if there are no ongoing migrations).

==== Aggregator API

The aggregation is split into three phases represented by three methods:

. `accumulate()`
. `combine()`
. `aggregate()`

There are also the following callbacks:

* `onAccumulationFinished()` called when the accumulation phase finishes
* `onCombinationFinished()` called when the combination phase finishes

These callbacks enable releasing the state that might have been initialized and
stored in the Aggregator - to reduce the network traffic.

Each phase is described below. See also the
link:https://docs.hazelcast.org/docs/latest/javadoc/com/hazelcast/aggregation/Aggregator.html[Aggregator Javadoc^]
for the API's details.

**Accumulation:**

During the accumulation phase each Aggregator accumulates all entries passed
to it by the query engine.
It accumulates only those pieces of information that are required to calculate
the aggregation result in the last phase - that's implementation specific.

In case of the `DoubleAverage` aggregation the Aggregator would accumulate:

* the sum of the elements it accumulated
* the count of the elements it accumulated

**Combination:**

Since aggregation is executed in parallel on each partition of the cluster,
the results need to be combined after the accumulation phase in order to be able
to calculate the final result.

In case of the `DoubleAverage` aggregation, the aggregator would sum up all
the sums of the elements and all the counts.


**Aggregation:**

Aggregation is the last phase that calculates the final result from the
results accumulated and combined in the preceding phases.

In case of the `DoubleAverage` aggregation, the Aggregator would just
divide the sum of the elements by their count (if non-zero).

==== Aggregations and Map Interfaces

Aggregations are available on `com.hazelcast.core.IMap` only.
IMap offers the method `aggregate` to apply the aggregation logic on
the map entries. This method can be called with or without a predicate. You can refer
to its link:https://docs.hazelcast.org/docs/latest/javadoc/com/hazelcast/core/IMap.html#aggregate-com.hazelcast.aggregation.Aggregator-[Javadoc^]
to see the method details.


==== Example Implementation

Here's an example implementation of the Aggregator:

[source,java]
----
include::{javasource}/distributedquery/SimpleFastAggregationsDemo.java[tag=fademo]
----

As you can see:

* the `accumulate()` method calculates the sum and count of the elements
* the `combine()` method combines the results from all the accumulations
* the `aggregate()` method calculates the final result.

==== Built-In Aggregations

The `com.hazelcast.aggregation.Aggregators` class provides a wide variety of built-in Aggregators.
The full list is presented below:

* `count`
* `distinct`
* `bigDecimal` `sum`/`avg`/`min`/`max`
* `bigInteger` `sum`/`avg`/`min`/`max`
* `double` `sum`/`avg`/`min`/`max`
* `integer` `sum`/`avg`/`min`/`max`
* `long` `sum`/`avg`/`min`/`max`
* `number` `avg`
* `comparable` `min`/`max`
* `fixedPointSum`, `floatingPointSum`

To use the any of these Aggregators, instantiate them using the `Aggregators`
factory class.

Each built-in Aggregator can also navigate to an attribute of the object passed
to the `accumulate()` method (via reflection). For example, `Aggregators.distinct("address.city")`
extracts the `address.city` attribute from the object passed to the Aggregator and
accumulate the extracted value.

==== Configuration Options

On each partition, after the entries have been passed to the aggregator, the
accumulation runs in parallel.
It means that each aggregator is cloned and receives a sub-set of the entries
received from a partition.
Then, it runs the accumulation phase in all of the cloned aggregators - at the
end, the result is combined into a single accumulation result.
It speeds up the processing by at least the factor of two - even in case of simple
aggregations. If the accumulation logic is more "heavy", the speed-up may be more significant.

In order to switch the accumulation into a sequential mode just set the
`hazelcast.aggregation.accumulation.parallel.evaluation` property to `false`
(it's set to `true` by default).

=== Projections

There are cases where instead of sending all the data returned by a query from
a member, you want to transform (strip down) each result object in order to avoid
redundant network traffic.

For example, you select all employees based on some criteria, but you just want to
return their name instead of the whole Employee object. It is easily doable with the
Projection API.

==== Projection API

The Projection API provides the method `transform()` which is called on each result
object. Its result is then gathered as the final query result entity. You can refer
to the link:https://docs.hazelcast.org/docs/latest/javadoc/com/hazelcast/projection/Projection.html[Projection Javadoc^]
for the API's details.

===== Projections and Map Interfaces

Projections are available on `com.hazelcast.core.IMap` only. IMap offers the method
`project` to apply the projection logic on the map entries. This method can be called
with or without a predicate. See its
link:https://docs.hazelcast.org/docs/latest/javadoc/com/hazelcast/core/IMap.html#project-com.hazelcast.projection.Projection-[Javadoc^]
to see the method details.


==== Example implementation

Let's consider the following domain object stored in an IMap:

[source,java]
----
public class Employee implements Serializable {

    private String name;

    public Employee() {
    }

    public String getName() {
        return name;
    }

    public void setName(String firstName) {
        this.name = name;
    }
}
----

To return just the names of the Employees, you can run the query in the following way:

[source,java]
----
Collection<String> names = employees.project(new Projection<Map.Entry<String, Employee>, String>() {

    @Override
    public String transform(Map.Entry<String, Employee> entry) {
        return entry.getValue().getName();
    }
}, somePredicate);
----


==== Built-In Projections

The `com.hazelcast.projection.Projections` class provides two built-in
Projections:

* `singleAttribute`
* `multiAttribute`

The `singleAttribute` Projection enables extracting a single attribute
from an object (via reflection). For example, `Projection.singleAttribute("address.city")`
extracts the `address.city` attribute from the object passed to the Projection.

The `multiAttribute` Projection enables extracting multiples attributes from an
object (via reflection). For example, `Projection.multiAttribute("address.city", "postalAddress.city")`
extracts both attributes from the object passed to the Projection and return them in an `Object[]` array.

=== Continuous Query Cache

A continuous query cache is used to cache the result of a continuous query. After
the construction of a continuous query cache, all changes on IMap are asynchronously
reflected to this cache via events. This makes this cache as an asynchronously updated
view of IMap. You can create a continuous query cache either on the client or member.

==== Keeping Query Results Local and Ready

A continuous query cache is beneficial when you need to query the distributed
`IMap` data in a very frequent and fast way. By using a continuous query cache,
the result of the query will always be ready and local to the application.

==== Accessing Continuous Query Cache from Member

The following code snippet shows how you can access a continuous query cache
from a member.

[source,java]
----
include::{javasource}/distributedquery/CQC.java[tag=cqc]
----

==== Accessing Continuous Query Cache from Client Side

The following code snippet shows how you can access a continuous query cache
from the client side.
The difference in this code from the member side code above is that you configure
and instantiate
a client instance instead of a member instance.

[source,java]
----
include::{javasource}/distributedquery/CQCClient.java[tag=cqcclient]
----

==== Features of Continuous Query Cache

The following features of continuous query cache are valid for both
the member and client:

* The initial query that is run on the existing `IMap` data during the
continuous query cache construction can be enabled/disabled according to
the supplied predicate via `QueryCacheConfig.setPopulate()`.
* Continuous query cache allows you to run queries with indexes and perform
event batching and coalescing.
* A continuous query cache is evictable. Note that a continuous query cache
has a default maximum capacity of 10000. If you need a non-evictable cache, you
should configure the eviction via `QueryCacheConfig.setEvictionConfig()`.
* A listener can be added to a continuous query cache using `QueryCache.addEntryListener()`.
* `IMap` events are reflected in continuous query cache in the same order as
they were generated on map entries. Since events are created on entries stored
in partitions, ordering of events is maintained based on the ordering within
the partition. You can add listeners to capture lost events using `EventLostListener`
and you can recover lost events with the method `QueryCache.tryRecover()`.
Recovery of lost events largely depends on the size of the buffer on Hazelcast members.
Default buffer size is 16 per partition, i.e., 16 events per partition can be maintained
in the buffer. If the event generation is high, setting the buffer size to a higher
number provides better chances of recovering lost events. You can set buffer size
with `QueryCacheConfig.setBufferSize()`. You can use the following example code for a
recovery case.
+
[source,java]
----
QueryCache queryCache = map.getQueryCache("cache-name", new SqlPredicate("this > 20"), true);
queryCache.addEntryListener(new EventLostListener() {
@Override
public void eventLost(EventLostEvent event) {
       queryCache.tryRecover();
      }
}, false);
----
+
* You can populate a continuous query cache with only the keys of its entries and
retrieve the subsequent values directly via `QueryCache.get()` from the underlying
`IMap`. This helps to decrease the initial population time when the values are very
large.

==== Configuring Continuous Query Cache

You can configure continuous query cache declaratively or programmatically; the
latter is mostly explained in the previous section. The parent configuration element
is `<query-caches>` which should be placed within your `<map>` configuration. You can
create your query caches using the  `<query-cache>` sub-element under `<query-caches>`.

The following is an example declarative configuration.


[source,xml]
----
<hazelcast>
    ...
    <map>
        <query-caches>
            <query-cache name="myContQueryCache">
                <include-value>true</include-value>
                <predicate type="class-name">com.hazelcast.examples.ExamplePredicate</predicate>
                <entry-listeners>
                    <entry-listener>...</entry-listener>
                </entry-listeners>
                <in-memory-format>BINARY</in-memory-format>
                <populate>true</populate>
                <coalesce>false</coalesce>
                <batch-size>2</batch-size>
                <delay-seconds>3</delay-seconds>
                <buffer-size>32</buffer-size>
                <eviction size="1000" max-size-policy="ENTRY_COUNT" eviction-policy="LFU"/>
                <indexes>
                    <index ordered="true">...</index>
                </indexes>
            </query-cache>
        </query-caches>
    </map>
    ...
</hazelcast>
----

Continuous query caches have the following configuration elements:

* `name`: Name of your continuous query cache.
* `include-value`: Specifies whether the value will be cached too. Its default
value is true.
* `predicate`: Predicate to filter events which are applied to the query cache.
* `entry-listeners`: Adds listeners (listener classes) for your query cache entries.
See the <<registering-map-listeners, Registering Map Listeners section>>.
* `in-memory-format`: Type of the data to be stored in your query cache.
See the <<setting-in-memory-format, Setting In-Memory Format section>>.
Its default value is BINARY.
* `populate`: Specifies whether the initial population of your query cache is
enabled. Its default value is true.
* `coalesce`: Specifies whether the coalescing of your query cache is enabled.
Its default value is false.
* `delay-seconds`: Minimum time in seconds that an event waits in the member's
buffer. Its default value is 0.
* `batch-size`: Batch size used to determine the number of events sent in a
batch to your query cache. Its default value is 1.
* `buffer-size`: Maximum number of events which can be stored in a partition
buffer. Its default value is 16.
* `eviction`: Configuration for the eviction of your query cache. See the
<<configuring-map-eviction, Configuring Map Eviction section>>.
* `indexes`: Indexes for your query cache defined by using this element's `<index>`
sub-elements. See the <<configuring-imap-indexes, Configuring IMap Indexes section>>.

Please take the following configuration considerations and publishing logic into account:

If  `delay-seconds` is equal to or smaller than **0**, then `batch-size` loses its
function. Each time there is an event, all the entries in the buffer are pushed to the subscriber.

If `delay-seconds` is bigger than **0**, the following logic applies:

* If `coalesce` is set to **true**, the buffer is checked for an event with the
same key; if so, it is overridden by the current event. Then:
** The current size of the buffer is checked: if the current size of the buffer
is equal to or larger than `batch-size`, then the events counted as much as the
`batch-size` are pushed to the subscriber. Otherwise, no events are sent.
** After finishing with checking `batch-size`, the `delay-seconds` is checked.
The buffer is scanned from the oldest to youngest entries; all the entries that are
older than `delay-seconds` are pushed to the subscriber.

=== MapReduce Deprecation and Removal

This section informs Hazelcast users about the MapReduce deprecation and removal,
its motivation and replacements.

==== Motivation

We've decided to deprecate the MapReduce framework in Hazelcast IMDG 3.8.
MapReduce support was completely removed in Hazelcast IMDG 4.0. The
MapReduce framework provided the distributed computing model and it was used
to back the old Aggregations system. Unfortunately the implementation didn't
live up to the expectations and adoption wasn't high, so it never got out of
Beta status. Apart from that the current shift in development away from M/R-like
processing to a more near-realtime, streaming approach left us with the decision
to deprecate and finally remove the MapReduce framework from Hazelcast IMDG. With
that said, we want to introduce the successors and replacements; fast Aggregations
on top of Query infrastructure and the Hazelcast Jet distributed computing platform.

==== Built-In Aggregations

MapReduce is a very powerful tool, however it's demanding in terms of space, time
and bandwidth. We realized that we don't need so much power when we simply want
to find out a simple metric such as the number of entries matching a predicate.
Therefore, the built-in aggregations were rebuilt on top of the existing Query
infrastructure (count, sum, min, max, mean, variance) which automatically leverages
any matching query index. The aggregations are computed in tho phases:

* 1st phase: on each member (scatter)
* 2nd phase: one member aggregates responses from members (gather)

It is not as flexible as a full-blown M/R system due to the 2nd phase being
single-member and the input can be massive in some use cases. The member doing
the 2nd step needs enough capacity to hold all intermediate results from all
members from the 1st step, but in practice it is sufficient for many aggregation
tasks like "find average" or "find highest" and other common examples.

The benefits are:

* improved performance
* simplified API
* utilization of existing indexes.

See the <<aggregations, Aggregations section>> for examples. If you
need a more powerful tool like MapReduce, then there is Hazelcast Jet!

==== Distributed Computation with Jet

Hazelcast Jet is the new distributed computing framework build on top of
Hazelcast IMDG. It uses directed acyclic graphs (DAG) to model relationships
between individual steps in the data processing pipeline.
Conceptually speaking, the MapReduce model simply states that distributed
computation on a large dataset can be boiled down to two kinds of computation
steps - a map step and a reduce step. One pair of map and reduce does one level
of aggregation over data. Complex computations typically require multiple such
steps. Multiple M/R-steps essentially form a DAG of operations, so that a DAG
execution model boils down to a generalization of the MapReduce model.
Therefore it is always possible to rewrite a MapReduce application to Hazelcast
Jet DAG or "pipeline of tasks" without conceptual changes.

The benefits can be summarized as follows:

* MapReduce steps are completely isolated (by definition). With the whole
computation modeled as a DAG, the Jet scheduler can optimize the operation
pipeline
* Hazelcast Jet provides a convenient high-level API (distributed j.u.stream).
The code stays compact but also offers a more concrete API to leverage the full
power of DAGs.

===== Moving MapReduce Tasks to Hazelcast Jet

We'll use the example of the word count application which summarizes a set of
documents into a mapping from each word to the total number of its occurrences
in the documents. This involves both a mapping stage where one document is
transformed into a stream of words and a reducing stage that performs a COUNT
DISTINCT operation on the stream and populates a Hazelcast IMap with the results.

This is the word count code in MapReduce (also available on
link:https://github.com/hazelcast/hazelcast-jet-code-samples/blob/v0.4/batch/mapreduce-migration/src/main/java/WordCountCoreApi.java[Hazelcast Jet Code Samples^]):

[source,java]
----
JobTracker t = hz.getJobTracker("word-count");
IMap<Long, String> documents = hz.getMap("documents");
LongSumAggregation<String, String> aggr = new LongSumAggregation<>();
Map<String, Long> counts =
        t.newJob(KeyValueSource.fromMap(documents))
         .mapper((Long x, String document, Context<String, Long> ctx) ->
                 Stream.of(document.toLowerCase().split("\\W+"))
                       .filter(w -> !w.isEmpty())
                       .forEach(w -> ctx.emit(w, 1L)))
         .combiner(aggr.getCombinerFactory())
         .reducer(aggr.getReducerFactory())
         .submit()
         .get();
----

Jet's Core API is strictly lower-level than MapReduce's because it can
be used to build the entire infrastructure that can drive MapReduce's
mapper, combiner and reducer, fully preserving the semantics of the MapReduce
job. However, this approach to migrating your code to Jet is not a good option
because the MapReduce API enforces a quite suboptimal computation model.
The simplest approach is implementing the job in terms of Jet's
`java.util.stream` support (Jet JUS for short):

[source,java]
----
IStreamMap<String, String> documents = jet.getMap("documents");
IMap<String, Long> counts = documents
        .stream()
        .flatMap(m -> Stream.of(m.getValue().toLowerCase().split("\\W+"))
                            .filter(w -> !w.isEmpty()))
        .collect(DistributedCollectors.toIMap(w -> w, w -> 1L, (left, right) -> left + right));
----

This can be taken as a general template to express a MapReduce job in terms
of Jet JUS: the logic of the mapper is inside `flatMap` and the logic of
both the combiner and the reducer is inside collect. Jet automatically applies
the optimization where the data stream is first "combined" locally on each member,
then the partial results "reduced" in the final step, after sending across the network.

Keep in mind that MapReduce and JUS use the same terminology, but with quite
different meaning: in JUS the final step is called "combine" (MapReduce calls
it "reduce") and the middle step is called "reduce" (MapReduce calls this one "combine").
MapReduce's "combine" collapses the stream in fixed-size batches, whereas in
Jet JUS "reduce" collapses the complete local dataset and sends just a single
item per distinct key to the final step. In Jet JUS, the final "combine" step
combines just one partial result per member into the total result, whereas in
MapReduce the final step "reduces" all the one-per-batch items to the final result.
Therefore, in Jet there are only O (distinct-key-count) items sent over the network
whereas in MapReduce it is still O (total-item-count) with just a linear scaling
factor equal to the configured batch size.

A complete example of the word count done with the Streams API can be found in the
link:https://github.com/hazelcast/hazelcast-jet-code-samples/tree/v0.4/batch/wordcount-j.u.s[Hazelcast Jet Code Samples^].
A minor difference is that the code on GitHub stores the documents line by line,
with the effect of a finer-grained distribution across the cluster.

To better understand how the JUS pipeline is executed by Jet, take a look at the file
`WordCount.java` in the `core/wordcount` module, which builds the same DAG as the Jet
JUS implementation, but using the Jet Core API. Here is a somewhat simplified DAG from
this example:

[source,java]
----
DAG dag = new DAG();
Vertex source = dag.newVertex("source", Processors.readMap("documents"))
                   .localParallelism(1);
Vertex map = dag.newVertex("map", Processors.flatMap(
           (String document) -> traverseArray(document.split("\\W+"))));
Vertex reduce = dag.newVertex("reduce", Processors.groupAndAccumulate(
           () -> 0L, (count, x) -> count + 1));
Vertex combine = dag.newVertex("combine", Processors.groupAndAccumulate(
           Entry::getKey,
           () -> 0L,
           (Long count, Entry<String, Long> wordAndCount) ->
                     count + wordAndCount.getValue())
);
Vertex sink = dag.newVertex("sink", writeMap("counts"));

dag.edge(between(source, map))
   .edge(between(map, reduce).partitioned(wholeItem(), HASH_CODE))
   .edge(between(reduce, combine).partitioned(entryKey()).distributed())
   .edge(between(combine, sink));
----

It is a simple cascade of vertices: source -> map -> reduce -> combine -> sink and
matches quite closely the workflow of a MapReduce job. On each member, a distinct
slice of data (IMap partitions stored locally) is ingested by the source vertex
and sent to map on the local member. The output of map are words and they travel
over a partitioned edge to reduce. Note that, as opposed to MapReduce, a single
instance of a processor doesn't count occurrences of just one word, but is responsible
for entire partitions. There are only as many processors as configured by the
`localParallelism` property. This is one of several examples where Jet's DAG
exposes performance-critical attributes of the computation to the user.

Another example of this can be seen in arguments passed to `partitioned(wholeItem(), HASH_CODE)`.
The user has a precise control over the partitioning key as well as the algorithm used
to map the key to a partition ID. In this case we use the whole item (the word) as the
key and apply the fast `HASH_CODE` strategy, which derives the partition ID from the
object's `hashCode()`.

The reduce -> combine edge is both partitioned and distributed. Whereas each cluster
member has its own reduce processor for any given word, there is only one combine
processor in the entire cluster for a given word. This is where network traffic happens:
reduce sends its local results for a word to that one combine processor in the cluster.
Note that here we didn't specify `HASH_CODE`; it is not guaranteed to be safe on a
distributed edge because on the target member the hashcode can come out differently.
For many value classes (like `String` and `Integer`) it is guaranteed to work, though,
because their hashcode explicitly specifies the function used. By default Jet applies the
slower but safer Hazelcast strategy: first serialize and then compute the MurmurHash3 of
the resulting blob. It is up to the user to ensure that the faster strategy is safe, or to
provide a custom strategy.

In the above example we can see many out-of-the-box processors being used:

* `readMap` to ingest the data from an IMap
* `flatMap` to perform a flat-map operation on incoming items (closely corresponds
to MapReduce's mapper)
* `groupAndAccumulate` to perform the reduction and combining

There are some more in the `Processors` class.
For even more flexibility we'll now show how you can implement a processor on your
own (also available in the Hazelcast Jet Code Samples repository):

[source,java]
----
public class MapReduce {

    public static void main(String[] args) throws Exception {
        Jet.newJetInstance();
        JetInstance jet = Jet.newJetInstance();
        try {
            DAG dag = new DAG();
            Vertex source = dag.newVertex("source", readMap("sourceMap"));
            Vertex map = dag.newVertex("map", MapP::new);
            Vertex reduce = dag.newVertex("reduce", ReduceP::new);
            Vertex combine = dag.newVertex("combine", CombineP::new);
            Vertex sink = dag.newVertex("sink", writeMap("sinkMap"));
            dag.edge(between(source, map))
               .edge(between(map, reduce).partitioned(wholeItem(), HASH_CODE))
               .edge(between(reduce, combine).partitioned(entryKey()).distributed())
               .edge(between(combine, sink.localParallelism(1)));
            jet.newJob(dag).execute().get();
        } finally {
            Jet.shutdownAll();
        }
    }

    private static class MapP extends AbstractProcessor {
        private final FlatMapper<Entry<Long, String>, String> flatMapper = flatMapper(
                (Entry<Long, String> e) -> new WordTraverser(e.getValue())
        );

        @Override
        protected boolean tryProcess0(@Nonnull Object item) {
            return flatMapper.tryProcess((Entry<Long, String>) item);
        }
    }

    private static class WordTraverser implements Traverser<String> {

        private final StringTokenizer tokenizer;

        WordTraverser(String document) {
            this.tokenizer = new StringTokenizer(document.toLowerCase());
        }

        @Override
        public String next() {
            return tokenizer.hasMoreTokens() ? tokenizer.nextToken() : null;
        }
    }

    private static class ReduceP extends AbstractProcessor {
        private final Map<String, Long> wordToCount = new HashMap<>();
        private final Traverser<Entry<String, Long>> resultTraverser =
                lazy(() -> traverseIterable(wordToCount.entrySet()));

        @Override
        protected boolean tryProcess0(@Nonnull Object item) {
            wordToCount.compute((String) item, (x, count) -> 1 + (count != null ? count : 0L));
            return true;
        }

        @Override
        public boolean complete() {
            return emitCooperatively(resultTraverser);
        }
    }

    private static class CombineP extends AbstractProcessor {
        private final Map<String, Long> wordToCount = new HashMap<>();
        private final Traverser<Entry<String, Long>> resultTraverser =
                lazy(() -> traverseIterable(wordToCount.entrySet()));

        @Override
        protected boolean tryProcess0(@Nonnull Object item) {
            final Entry<String, Long> e = (Entry<String, Long>) item;
            wordToCount.compute(e.getKey(),
                    (x, count) -> e.getValue() + (count != null ? count : 0L));
            return true;
        }

        @Override
        public boolean complete() {
            return emitCooperatively(resultTraverser);
        }
    }
}
----

One of the challenges of implementing a custom processor is cooperativeness: it must
back off as soon as there is no more room in the output buffer (the outbox). This
example shows how to make use of another line of convenience provided at this lower
level, which takes care of almost all the mechanics involved. One gotcha is that a
simple `for` loop must be converted to a stateful iterator-style object, like
`WordTraverser` in the above code. To make this conversion as painless as possible we
chose to not require a Java Iterator, but defined our own `Traverser` interface with
just a single method to implement. This means that `Traverser` is a functional
interface and can often be implemented with a one-liner lambda.

==== Jet Compared with New Aggregations

Hazelcast has native support for aggregation operations on the contents of its
distributed data structures. They operate on the assumption that the aggregating
function is commutative and associative, which allows the two-tiered approach where
first the local data is aggregated, then all the local subresults sent to one member,
where they are combined and returned to the user. This approach works quite well as
long as the result is of manageable size. Many interesting aggregations produce an O(1)
result and for those, the native aggregations are a good match.

The main area where native aggregations may not be sufficient are the operations that
group the data by key and produce results of size O (`keyCount`). The architecture of
Hazelcast aggregations is not well adapted to this use case, although it still works
even for moderately-sized results (up to 100 MB, as a ballpark figure). Beyond these
numbers, and whenever something more than a single aggregation step is needed, Jet
becomes the preferred choice. In the mentioned use case Jet helps because it doesn't
send the entire hashtables in serialized form and materialize all the results on the
user's machine, but rather streams the key-value pairs directly into a target IMap.
Since it is a distributed structure, it doesn't focus its load on a single member.

Jet's DAG paradigm offers much more than the basic map-reduce-combine cascade. Among
other setups, it can compose several such cascades and also perform co-grouping,
joining and many other operations in complex combinations.
